CCS PCM C Compiler, Version 3.221, 27853               18-IX-05 10:59

               Filename: D:\MLAB\_Z\DART01B\SW\1_02\DART.LST

               ROM used: 1098 words (27%)
                         Largest free fragment is 2048
               RAM used: 25 (14%) at main() level
                         43 (25%) worst case
               Stack:    6 worst case (3 in main + 3 for interrupts)

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   25F
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   7F,W
0009:  MOVWF  20
000A:  MOVF   0A,W
000B:  MOVWF  28
000C:  CLRF   0A
000D:  SWAPF  20,F
000E:  MOVF   04,W
000F:  MOVWF  22
0010:  MOVF   77,W
0011:  MOVWF  23
0012:  MOVF   78,W
0013:  MOVWF  24
0014:  MOVF   79,W
0015:  MOVWF  25
0016:  MOVF   7A,W
0017:  MOVWF  26
0018:  MOVF   7B,W
0019:  MOVWF  27
001A:  BCF    03.7
001B:  BCF    03.5
001C:  MOVLW  8C
001D:  MOVWF  04
001E:  BTFSS  00.3
001F:  GOTO   022
0020:  BTFSC  0C.3
0021:  GOTO   039
0022:  BTFSS  0B.5
0023:  GOTO   026
0024:  BTFSC  0B.2
0025:  GOTO   03B
0026:  MOVF   22,W
0027:  MOVWF  04
0028:  MOVF   23,W
0029:  MOVWF  77
002A:  MOVF   24,W
002B:  MOVWF  78
002C:  MOVF   25,W
002D:  MOVWF  79
002E:  MOVF   26,W
002F:  MOVWF  7A
0030:  MOVF   27,W
0031:  MOVWF  7B
0032:  MOVF   28,W
0033:  MOVWF  0A
0034:  SWAPF  21,W
0035:  MOVWF  03
0036:  SWAPF  7F,F
0037:  SWAPF  7F,W
0038:  RETFIE
0039:  BCF    0A.3
003A:  GOTO   0A5
003B:  BCF    0A.3
003C:  GOTO   0D3
....................  // DART01A verze programu 1.02  
.................... // (c)miho 2005  
.................... //  
.................... // 1.00 Uvodni verze  
.................... // 1.01 Doplneno nasatvovani parametru rozjezdu P2 u standardniho algoritmu  
.................... // 1.02 Doplnena deaktivace vyvodu pro LED (LED tato verze programu nepouziva)  
....................   
.................... #include "DART.h" 
....................  // DART01A verze programu 1.00  
.................... // (c)miho 2005  
....................   
.................... #include <16F88.h>                     // standardni definice konstant 
....................  //////// Header file for the PIC16F88  
.................... #device PIC16F88  
.................... #list 
.................... #include <16F88_Reg.h>                 // standardni definice vsech FSR 
.................... #list  
....................  
....................   
.................... #device adc=8                          // AD prevodnik jen na 8 bitu  
.................... #define xclock 4168000                 // muj konkretni PIC je trochu rychlejsi  
.................... #use delay(clock=xclock,restart_wdt)  
*
00FD:  MOVLW  11
00FE:  SUBWF  3F,F
00FF:  BTFSS  03.0
0100:  GOTO   10F
0101:  MOVLW  3F
0102:  MOVWF  04
0103:  MOVLW  FC
0104:  ANDWF  00,F
0105:  BCF    03.0
0106:  RRF    00,F
0107:  RRF    00,F
0108:  MOVF   00,W
0109:  BTFSC  03.2
010A:  GOTO   10F
010B:  GOTO   10D
010C:  CLRWDT
010D:  DECFSZ 00,F
010E:  GOTO   10C
010F:  BCF    0A.3
0110:  GOTO   2AA (RETURN)
*
020D:  MOVLW  3E
020E:  MOVWF  04
020F:  MOVF   00,W
0210:  BTFSC  03.2
0211:  GOTO   223
0212:  MOVLW  01
0213:  MOVWF  78
0214:  MOVLW  BF
0215:  MOVWF  77
0216:  CLRWDT
0217:  DECFSZ 77,F
0218:  GOTO   216
0219:  DECFSZ 78,F
021A:  GOTO   214
021B:  MOVLW  58
021C:  MOVWF  77
021D:  DECFSZ 77,F
021E:  GOTO   21D
021F:  NOP
0220:  CLRWDT
0221:  DECFSZ 00,F
0222:  GOTO   212
0223:  RETLW  00
.................... #fuses INTRC_IO, WDT, NOPUT, NOPROTECT, NOBROWNOUT, MCLR, NOLVP, NOCPD, NODEBUG, CCPB3  
....................  
....................   
....................   
.................... #define BEEP0     PIN_A6   // pipak, prvni vystup  
.................... #define BEEP1     PIN_A7   // pipak, druhy vystup  
.................... #define PWM       PIN_B3   // PWM vystup pro menic  
.................... #define REFPOWER  PIN_B1   // napajeni zdroje Vref  
.................... #define MOTOR     PIN_B2   // zapinani motoru  
.................... #define SW0       PIN_B7   // konfiguracni prepinac 0  
.................... #define SW1       PIN_B6   // konfiguracni prepinac 1  
.................... #define LED       PIN_B4   // dioda LED v elektornice DART01B  
....................   
....................   
.................... void InitRS232()  
.................... // Inicializace HW RS232 (pro ladici vystupy)  
.................... {  
....................    SPBRG=xclock/9600/16-1; // ryclost 9600Bd  
*
00F1:  MOVLW  1A
00F2:  BSF    03.5
00F3:  MOVWF  19
....................    RCSTA=0b10000000;       // enable USART  
00F4:  MOVLW  80
00F5:  BCF    03.5
00F6:  MOVWF  18
....................    TXSTA=0b00100100;       // BRGH=1, TX enable  
00F7:  MOVLW  24
00F8:  BSF    03.5
00F9:  MOVWF  18
.................... }  
00FA:  BCF    03.5
00FB:  BCF    0A.3
00FC:  GOTO   28C (RETURN)
....................   
....................   
.................... void Putc(char c)  
.................... // Posilani znaku pres HW RS232  
.................... {  
....................    while(TRMT==0);         // cekej na prazdny TX buffer  
*
0111:  BSF    03.5
0112:  BTFSC  18.1
0113:  GOTO   116
0114:  BCF    03.5
0115:  GOTO   111
....................    TXREG=c;                // predej data  
0116:  BCF    03.5
0117:  MOVF   42,W
0118:  MOVWF  19
.................... }  
0119:  RETLW  00
....................   
....................   
.................... // Globalni promenna pro data posilana na SSP  
.................... //   Nastavuje se funkci MotorPatternSet()  
.................... //   Vyuziva se v prerusovaci rutine IntSSP()  
.................... unsigned int8 MotorPattern;   // aktualni data pro SSP jednotku  
....................   
....................   
.................... void MotorPatternSet(unsigned int Gear)  
.................... // Na zaklade rychlostniho stupne nastavi MotorPattern pro SSP  
.................... // Rychlost 0 znamena stop, rychlost 8 je maximum  
.................... {  
....................    // Tabulka rychlost -> pattern pro SSP  
....................    unsigned int8 const ExpTab[8] = {0x02,0x06,0x0e,0x1e,0x3e,0x7e,0xfe,0xff};  
....................   
....................    // Vyber patternu  
....................    if (Gear==0)                     // stav 0 znamena stop  
*
00AA:  MOVF   45,F
00AB:  BTFSS  03.2
00AC:  GOTO   0B9
....................    {  
....................       output_low(MOTOR);            // klidovy stav  
00AD:  BSF    03.5
00AE:  BCF    06.2
00AF:  BCF    03.5
00B0:  BCF    06.2
....................       SSPSTAT = 0;  
00B1:  BSF    03.5
00B2:  CLRF   14
....................       SSPCON1 = 0;                  // SPI stop  
00B3:  BCF    03.5
00B4:  CLRF   14
....................       disable_interrupts(INT_SSP);  // neni preruseni od SSP  
00B5:  BSF    03.5
00B6:  BCF    0C.3
....................    }  
....................    else                             // rizeny vykon  
00B7:  GOTO   0D1
00B8:  BCF    03.5
....................    {  
....................       if (Gear>7)                   // stav 8 a vice znamena plny vykon  
00B9:  MOVF   45,W
00BA:  SUBLW  07
00BB:  BTFSC  03.0
00BC:  GOTO   0BF
....................       {  
....................          Gear=8;                    // plny plyn  
00BD:  MOVLW  08
00BE:  MOVWF  45
....................       }  
....................   
....................       MotorPattern=ExpTab[--Gear];  // prevod z hodnoty plynu na data pro SSP  
00BF:  DECF   45,F
00C0:  MOVF   45,W
00C1:  CALL   03D
00C2:  MOVWF  78
00C3:  MOVWF  2A
....................       output_low(MOTOR);            // klidovy stav  
00C4:  BSF    03.5
00C5:  BCF    06.2
00C6:  BCF    03.5
00C7:  BCF    06.2
....................       SSPSTAT = 0;  
00C8:  BSF    03.5
00C9:  CLRF   14
....................       SSPCON1 = 0x22;               // SPI OSC/64  
00CA:  MOVLW  22
00CB:  BCF    03.5
00CC:  MOVWF  14
....................   
....................       SSPBUF=MotorPattern;          // prvni data pro vyslani  
00CD:  MOVF   2A,W
00CE:  MOVWF  13
....................       enable_interrupts(INT_SSP);   // az budou vyslana prijde interrupt od SSP  
00CF:  BSF    03.5
00D0:  BSF    0C.3
....................    }  
.................... }  
00D1:  BCF    03.5
00D2:  RETLW  00
....................   
....................   
.................... // Obsluha preruseni od SSP jednotky, posila data z promenne MotorRun do SSP.  
.................... #INT_SSP  
.................... void IntSSP()  
.................... {  
....................    SSPBUF=MotorPattern;             // znova hdnota PWM patternu na SSP  
*
00A5:  MOVF   2A,W
00A6:  MOVWF  13
.................... }  
....................   
....................   
00A7:  BCF    0C.3
00A8:  BCF    0A.3
00A9:  GOTO   026
.................... void MotorSet(unsigned int Gear)  
*
0224:  CLRF   29
0225:  BTFSC  0B.7
0226:  BSF    29.7
0227:  BCF    0B.7
.................... // Nastavi vykon motoru dle hodnoty Gear a zahaji posilani PWM dat pres SSP pod prerusenim  
.................... // od SSP jednotky  
.................... //    0   stop  
.................... //    1-7 pocet 1/8 vykonu  
.................... //    >7  plny vykon  
.................... {  
....................    // Nastav PWM pattern  
....................    MotorPatternSet(Gear);           // nastav PWM pattern pro SSP  
0228:  MOVF   3E,W
0229:  MOVWF  45
022A:  CALL   0AA
022B:  BTFSC  29.7
022C:  BSF    0B.7
....................   
....................    // Povol preruseni  
....................    enable_interrupts(GLOBAL);       // povol preruseni  
022D:  MOVLW  C0
022E:  IORWF  0B,F
.................... }  
022F:  RETLW  00
....................   
....................   
.................... void InitT0()  
.................... // Inicializace casovace T0 (cca 1000x za sekundu)  
.................... {  
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_4);  // T0 z internich hodin 1/4  
*
018A:  BSF    03.5
018B:  MOVF   01,W
018C:  ANDLW  C0
018D:  IORLW  01
018E:  MOVWF  01
....................    enable_interrupts(INT_RTCC);              // generuj preruseni od T0  
018F:  BCF    03.5
0190:  BSF    0B.5
....................    enable_interrupts(GLOBAL);                // povol preruseni  
0191:  MOVLW  C0
0192:  IORWF  0B,F
.................... }  
0193:  BCF    0A.3
0194:  GOTO   2DF (RETURN)
....................   
....................   
.................... // Globalni promenna pro mereni casu  
.................... //   Nastavuje se procedurou TimeSet()  
.................... //   Testuje se funkci TimeIf()  
.................... //   Modifikuje se pri preruseni od casovace IntTo()  
.................... unsigned int16 TimeTime;  
....................   
....................   
.................... void TimerSet(unsigned int16 Time)  
.................... // Nastavi casovac na zadany pocet ms  
.................... // Test uplynuti casu se dela pomoci TimerIf()  
.................... {  
....................    // Nastav hodnotu  
....................    disable_interrupts(INT_RTCC);    // nesmi prijit preruseni  
*
0230:  BCF    0B.5
....................    TimeTime=Time;                   // pri nastavovani hodnoty  
0231:  MOVF   3F,W
0232:  MOVWF  2C
0233:  MOVF   3E,W
0234:  MOVWF  2B
....................    enable_interrupts(INT_RTCC);     // promenne (o delce vice nez 8 bitu)  
0235:  BSF    0B.5
.................... }  
0236:  RETLW  00
....................   
....................   
.................... int1 TimerIf()  
.................... // Vraci TRUE pokud casovac jiz dobehl  
.................... {  
....................    int1 Flag;                       // pomocna promenna  
....................   
....................    // Otestuj casovac  
....................    disable_interrupts(INT_RTCC);    // nesmi prijit preruseni  
0237:  BCF    0B.5
....................    Flag=(TimeTime==0);              // behem testu promenne  
0238:  MOVF   2B,F
0239:  BTFSS  03.2
023A:  GOTO   23E
023B:  MOVF   2C,F
023C:  BTFSC  03.2
023D:  GOTO   240
023E:  MOVLW  00
023F:  GOTO   241
0240:  MOVLW  01
0241:  MOVWF  78
0242:  BTFSC  78.0
0243:  GOTO   246
0244:  BCF    3E.0
0245:  GOTO   247
0246:  BSF    3E.0
....................    enable_interrupts(INT_RTCC);     // ted uz muze  
0247:  BSF    0B.5
....................   
....................    // Navratova hodnota  
....................    return Flag;                     // TRUE znamena dobehl casovac  
0248:  MOVLW  00
0249:  BTFSC  3E.0
024A:  MOVLW  01
024B:  MOVWF  78
.................... }  
024C:  RETLW  00
....................   
....................   
.................... // Globalni promenne pro akceleraci  
.................... //   Nastavuje se metodou MotorStart()  
.................... //   Pouziva se v obsluze preruseni IntT0()  
.................... unsigned int8 MotorTime;            // aktualni casovac pro rozjezd  
.................... unsigned int8 MotorDelay;           // spozdeni mezi razenim rychlosti  
.................... unsigned int8 MotorGear;            // rychlostni stupen  
....................   
....................   
.................... void MotorStart(unsigned int8 Delay)  
.................... // Provede rizeny rozjezd motoru  
.................... // Parametrem je prodleva mezi razenim rychlosti v ms  
.................... {  
....................    disable_interrupts(INT_RTCC);  
024D:  BCF    0B.5
....................    MotorGear=1;  
024E:  MOVLW  01
024F:  MOVWF  2F
....................    MotorDelay=Delay;  
0250:  MOVF   3E,W
0251:  MOVWF  2E
....................    MotorTime=MotorDelay;  
0252:  MOVF   2E,W
0253:  MOVWF  2D
....................    enable_interrupts(INT_RTCC);  
0254:  BSF    0B.5
0255:  CLRF   29
0256:  BTFSC  0B.7
0257:  BSF    29.7
0258:  BCF    0B.7
....................   
....................    MotorPatternSet(1);  
0259:  MOVLW  01
025A:  MOVWF  45
025B:  CALL   0AA
025C:  BTFSC  29.7
025D:  BSF    0B.7
.................... }  
025E:  RETLW  00
....................   
....................   
.................... #INT_TIMER0  
.................... void IntT0()  
.................... // Preruseni od casovace cca 1000x za sekundu  
.................... {  
....................    // Odpocitavani casovace  
....................    if (TimeTime) TimeTime--;  
*
00D3:  MOVF   2B,W
00D4:  IORWF  2C,W
00D5:  BTFSC  03.2
00D6:  GOTO   0DB
00D7:  MOVF   2B,W
00D8:  BTFSC  03.2
00D9:  DECF   2C,F
00DA:  DECF   2B,F
....................   
....................    // Obsluha akcelerace  
....................    if (MotorTime) MotorTime--;                           // dekrementuj casovac rozjezdu  
00DB:  MOVF   2D,F
00DC:  BTFSS  03.2
00DD:  DECF   2D,F
....................    if ((MotorGear>0) && (MotorGear<8) && (!MotorTime))   // dalsi rychlostni stupen  
00DE:  MOVF   2F,F
00DF:  BTFSC  03.2
00E0:  GOTO   0EE
00E1:  MOVF   2F,W
00E2:  SUBLW  07
00E3:  BTFSS  03.0
00E4:  GOTO   0EE
00E5:  MOVF   2D,F
00E6:  BTFSS  03.2
00E7:  GOTO   0EE
....................    {  
....................       MotorTime=MotorDelay;         // znovu nastav casovac  
00E8:  MOVF   2E,W
00E9:  MOVWF  2D
....................       MotorGear++;                  // dalsi rychlost  
00EA:  INCF   2F,F
....................       MotorPatternSet(MotorGear);   // nastav rychlost  
00EB:  MOVF   2F,W
00EC:  MOVWF  45
00ED:  CALL   0AA
....................    }  
.................... }  
....................   
....................   
.................... // Cteni dat z AD prevodniku, zadava se cislo kanalu  
00EE:  BCF    0B.2
00EF:  BCF    0A.3
00F0:  GOTO   026
.................... int8 ReadAD(int8 Ch)  
.................... {  
....................    // Pokud merim Vref zapnu si jeho napajeni  
....................    if (Ch==4) output_high(REFPOWER);  
*
0195:  MOVF   3E,W
0196:  SUBLW  04
0197:  BTFSS  03.2
0198:  GOTO   19D
0199:  BSF    03.5
019A:  BCF    06.1
019B:  BCF    03.5
019C:  BSF    06.1
....................   
....................    // Inicializace a cislo kanalu  
....................    ADCON1=0x30;         // Vref+-, bez deleni hodin, Left Justify  
019D:  MOVLW  30
019E:  BSF    03.5
019F:  MOVWF  1F
....................    ADCON0=0x41+(Ch<<3); // on, Tosc/8, cislo kanalu  
01A0:  BCF    03.5
01A1:  RLF    3E,W
01A2:  MOVWF  77
01A3:  RLF    77,F
01A4:  RLF    77,F
01A5:  MOVLW  F8
01A6:  ANDWF  77,F
01A7:  MOVF   77,W
01A8:  ADDLW  41
01A9:  MOVWF  1F
....................   
....................    // Mereni  
....................    delay_us(50);        // doba na prepnuti kanalu  
01AA:  CLRWDT
01AB:  MOVLW  10
01AC:  MOVWF  77
01AD:  DECFSZ 77,F
01AE:  GOTO   1AD
01AF:  NOP
01B0:  NOP
....................    ADCON0 |= 4;         // start prevodu  
01B1:  BSF    1F.2
....................    delay_us(50);        // doba na prevod  
01B2:  CLRWDT
01B3:  MOVLW  10
01B4:  MOVWF  77
01B5:  DECFSZ 77,F
01B6:  GOTO   1B5
01B7:  NOP
01B8:  NOP
....................   
....................    // Vypnu napajeni Vref (vzdycky)  
....................    output_low(REFPOWER);  
01B9:  BSF    03.5
01BA:  BCF    06.1
01BB:  BCF    03.5
01BC:  BCF    06.1
....................   
....................    // Navrat hodnoty  
....................    return ADRESH;  
01BD:  MOVF   1E,W
01BE:  MOVWF  78
.................... }  
01BF:  RETLW  00
....................   
....................   
.................... void main()  
.................... {  
*
025F:  CLRF   04
0260:  MOVLW  1F
0261:  ANDWF  03,F
0262:  BSF    03.5
0263:  BCF    1F.4
0264:  BCF    1F.5
0265:  MOVF   1B,W
0266:  ANDLW  80
0267:  MOVWF  1B
0268:  MOVLW  07
0269:  MOVWF  1C
026A:  MOVF   1C,W
026B:  BCF    03.5
026C:  BCF    0D.6
....................    unsigned int8 Debug;    // Promenna pro rezim cinnosti (stav prepinacu)  
....................    unsigned int8 i;  
....................   
....................    // Hodiny  
....................    OSCCON = 0x62;          // 4 MHz interni RC oscilator  
026D:  MOVLW  62
026E:  BSF    03.5
026F:  MOVWF  0F
....................   
....................    // Digitalni vystupy  
....................    output_low(PWM);        // PWM vystup  
0270:  BCF    06.3
0271:  BCF    03.5
0272:  BCF    06.3
....................    output_low(MOTOR);      // Proud do motoru  
0273:  BSF    03.5
0274:  BCF    06.2
0275:  BCF    03.5
0276:  BCF    06.2
....................    output_low(REFPOWER);   // Napajeni Vref  
0277:  BSF    03.5
0278:  BCF    06.1
0279:  BCF    03.5
027A:  BCF    06.1
....................    output_low(LED);        // LED dioda nesviti  
027B:  BSF    03.5
027C:  BCF    06.4
027D:  BCF    03.5
027E:  BCF    06.4
....................    port_b_pullups(TRUE);   // Zbyvajici vyvody portu B  
027F:  BSF    03.5
0280:  BCF    01.7
....................   
....................    // Watch Dog  
....................    PSA=0;                  // preddelic prirazen casovaci  
0281:  BCF    01.3
....................    WDTCON=0x0E;            // Watch Dog cca 130ms  
0282:  MOVLW  0E
0283:  BCF    03.5
0284:  BSF    03.6
0285:  MOVWF  05
....................   
....................    // Analogove vstupy  
....................    ANSEL = 0x1F;           // AN0 az AN4  
0286:  MOVLW  1F
0287:  BSF    03.5
0288:  BCF    03.6
0289:  MOVWF  1B
....................   
....................    // nastaveni RS232  
....................    InitRS232();            // inicializace HW RS232 (nutno pockat cca 10ms)  
028A:  BCF    03.5
028B:  GOTO   0F1
....................   
....................    // Pipnuti (a cekani)  
....................    for (i=1;i<30;i++)      // pocet 1/2 period  
028C:  MOVLW  01
028D:  MOVWF  31
028E:  MOVF   31,W
028F:  SUBLW  1D
0290:  BTFSS  03.0
0291:  GOTO   2AE
....................    {  
....................       int1 beep;           // stavova promenna pro pipak  
....................   
....................       output_bit(BEEP0,beep);  
0292:  BTFSC  32.0
0293:  GOTO   296
0294:  BCF    05.6
0295:  GOTO   297
0296:  BSF    05.6
0297:  BSF    03.5
0298:  BCF    05.6
....................       beep=~beep;  
0299:  MOVLW  01
029A:  BCF    03.5
029B:  XORWF  32,F
....................       output_bit(BEEP1,beep);  
029C:  BTFSC  32.0
029D:  GOTO   2A0
029E:  BCF    05.7
029F:  GOTO   2A1
02A0:  BSF    05.7
02A1:  BSF    03.5
02A2:  BCF    05.7
....................       delay_us(1000);  
02A3:  CLRWDT
02A4:  MOVLW  09
02A5:  BCF    03.5
02A6:  MOVWF  3E
02A7:  MOVLW  6C
02A8:  MOVWF  3F
02A9:  GOTO   0FD
02AA:  DECFSZ 3E,F
02AB:  GOTO   2A7
....................    }  
02AC:  INCF   31,F
02AD:  GOTO   28E
....................   
....................    // Rozhodnuti o rezimu cinnosti (cteni stavu prepinacu)  
....................    Debug=0;  
02AE:  CLRF   30
....................    if (~input(SW0)) Debug|=1;    // precti bit 0  
02AF:  BSF    03.5
02B0:  BSF    06.7
02B1:  BCF    03.5
02B2:  BTFSS  06.7
02B3:  BSF    30.0
....................    if (~input(SW1)) Debug|=2;    // precti bit 1  
02B4:  BSF    03.5
02B5:  BSF    06.6
02B6:  BCF    03.5
02B7:  BTFSS  06.6
02B8:  BSF    30.1
....................    output_low(SW0);              // nastav L aby se snizila spotreba  
02B9:  BSF    03.5
02BA:  BCF    06.7
02BB:  BCF    03.5
02BC:  BCF    06.7
....................    output_low(SW1);              // na obou vstupech  
02BD:  BSF    03.5
02BE:  BCF    06.6
02BF:  BCF    03.5
02C0:  BCF    06.6
....................   
....................    // Zobrazeni rezimu (na ladici seriovy vystup)  
....................    printf(Putc,"\fMode:%d",Debug);  
02C1:  CLRF   3E
02C2:  MOVF   3E,W
02C3:  CALL   049
02C4:  INCF   3E,F
02C5:  MOVWF  77
02C6:  MOVWF  42
02C7:  CALL   111
02C8:  MOVLW  06
02C9:  SUBWF  3E,W
02CA:  BTFSS  03.2
02CB:  GOTO   2C2
02CC:  MOVF   30,W
02CD:  MOVWF  3F
02CE:  MOVLW  18
02CF:  MOVWF  40
02D0:  GOTO   12F
....................   
....................    // Inicializace PWM  
....................    PR2     = 0x1F;      // perioda PWM casovace  
02D1:  MOVLW  1F
02D2:  BSF    03.5
02D3:  MOVWF  12
....................    T2CON   = 0x04;      // povoleni casovace T2 bez preddelicu a postdelicu  
02D4:  MOVLW  04
02D5:  BCF    03.5
02D6:  MOVWF  12
....................    CCP1CON = 0x0C;      // PWM mode, lsb bity nulove  
02D7:  MOVLW  0C
02D8:  MOVWF  17
....................    CCPR1L  =    0;      // na zacatku nulova data  
02D9:  CLRF   15
....................    output_low(PWM);     // PWM vystup  
02DA:  BSF    03.5
02DB:  BCF    06.3
02DC:  BCF    03.5
02DD:  BCF    06.3
....................   
....................    // Inicializace casovace  
....................    InitT0();            // nastav casovac na cca 1ms  
02DE:  GOTO   18A
....................   
....................    // ALG=1 Test menice PWM a rozjezdoveho PWM  
....................    // ========================================  
....................    // P1 nastavuje primo stridu hlavniho PWM menice  
....................    // P2 nastavuje rychlostni stupen spinace motoru (rychlostni stupne 0-8)  
....................    // Trvale nacita P1 a P2 a nastavuje podle nich akcni hodnoty menicu  
....................    if (Debug==1)  
02DF:  DECFSZ 30,W
02E0:  GOTO   31A
....................    {  
....................       unsigned int8 Data1;       // poteniometr P1 = PWM  
....................       unsigned int8 Data2;       // poteniometr P2 = Rozjezd  
....................   
....................       while (1)  
....................       {  
....................          // watch dog  
....................          restart_wdt();  
02E1:  CLRWDT
....................   
....................          // mereni vstupu  
....................          Data1=ReadAD(0);        // nacti parametr pro PWM  
02E2:  CLRF   3E
02E3:  CALL   195
02E4:  MOVF   78,W
02E5:  MOVWF  33
....................          Data1>>=2;              // redukuj rozsah na 0 az 63  
02E6:  RRF    33,F
02E7:  RRF    33,F
02E8:  MOVLW  3F
02E9:  ANDWF  33,F
....................          Data2=ReadAD(1);        // nacti parametr pro rozjezd  
02EA:  MOVLW  01
02EB:  MOVWF  3E
02EC:  CALL   195
02ED:  MOVF   78,W
02EE:  MOVWF  34
....................          Data2>>=4;              // redukuj rozsah na 0 az 15  
02EF:  SWAPF  34,F
02F0:  MOVLW  0F
02F1:  ANDWF  34,F
....................   
....................          // zobrazeni  
....................          printf(Putc,"\nPWM:%03u RUN:%03u",Data1,Data2);  
02F2:  CLRF   3E
02F3:  MOVF   3E,W
02F4:  CALL   056
02F5:  INCF   3E,F
02F6:  MOVWF  77
02F7:  MOVWF  42
02F8:  CALL   111
02F9:  MOVLW  05
02FA:  SUBWF  3E,W
02FB:  BTFSS  03.2
02FC:  GOTO   2F3
02FD:  MOVF   33,W
02FE:  MOVWF  40
02FF:  CLRF   41
0300:  CALL   1C0
0301:  MOVLW  09
0302:  MOVWF  3F
0303:  MOVF   3F,W
0304:  CALL   056
0305:  INCF   3F,F
0306:  MOVWF  77
0307:  MOVWF  42
0308:  CALL   111
0309:  MOVLW  0E
030A:  SUBWF  3F,W
030B:  BTFSS  03.2
030C:  GOTO   303
030D:  MOVF   34,W
030E:  MOVWF  40
030F:  CLRF   41
0310:  CALL   1C0
....................          delay_ms(20);  
0311:  MOVLW  14
0312:  MOVWF  3E
0313:  CALL   20D
....................   
....................          // nastaveni parametru PWM  
....................          CCPR1L = Data1;  
0314:  MOVF   33,W
0315:  MOVWF  15
....................   
....................          // nastaveni parametru RUN  
....................          MotorSet(Data2);  
0316:  MOVF   34,W
0317:  MOVWF  3E
0318:  CALL   224
....................       }  
0319:  GOTO   2E1
....................    }  
....................   
....................    // ALG=2 Testovani rozjezdu  
....................    // ========================  
....................    // P2 nastavuje cas mezi stupni razeni pro rozjezd v ms  
....................    // Po resetu 2 sekundy pocka, 2 sekundy jede a nakonec zastavi motor  
....................    if (Debug==2)  
031A:  MOVF   30,W
031B:  SUBLW  02
031C:  BTFSS  03.2
031D:  GOTO   36B
....................    {  
....................       int8 Data;  
....................       int8 Start;  
....................   
....................       Start=0;                               // uvodni stav  
031E:  CLRF   36
....................       while(1)  
....................       {  
....................          // Nacti a zobraz parametr  
....................          Data=ReadAD(1);                     // potenciometr P2 = rozjezd  
031F:  MOVLW  01
0320:  MOVWF  3E
0321:  CALL   195
0322:  MOVF   78,W
0323:  MOVWF  35
....................          printf(Putc,"\nRUN:%3ums ",Data);   // zobraz  
0324:  CLRF   3E
0325:  MOVF   3E,W
0326:  CALL   06D
0327:  INCF   3E,F
0328:  MOVWF  77
0329:  MOVWF  42
032A:  CALL   111
032B:  MOVLW  05
032C:  SUBWF  3E,W
032D:  BTFSS  03.2
032E:  GOTO   325
032F:  MOVF   35,W
0330:  MOVWF  40
0331:  MOVLW  10
0332:  MOVWF  41
0333:  CALL   1C0
0334:  MOVLW  6D
0335:  MOVWF  42
0336:  CALL   111
0337:  MOVLW  73
0338:  MOVWF  42
0339:  CALL   111
033A:  MOVLW  20
033B:  MOVWF  42
033C:  CALL   111
....................          delay_ms(10);                       // prodleva pro terminal  
033D:  MOVLW  0A
033E:  MOVWF  3E
033F:  CALL   20D
....................   
....................          // Uvodni pauza  
....................          if (Start==0)                       // spousti se 1x na zacatku  
0340:  MOVF   36,F
0341:  BTFSS  03.2
0342:  GOTO   349
....................          {  
....................             Start++;                         // dalsi stav je cekani  
0343:  INCF   36,F
....................             TimerSet(2000);                  // na dokonceni uvodni prodlevy  
0344:  MOVLW  07
0345:  MOVWF  3F
0346:  MOVLW  D0
0347:  MOVWF  3E
0348:  CALL   230
....................          }  
....................   
....................          // Rozjezd  
....................          if ((Start==1) && TimerIf())  
0349:  DECFSZ 36,W
034A:  GOTO   35B
034B:  CALL   237
034C:  MOVF   78,F
034D:  BTFSC  03.2
034E:  GOTO   35B
....................          {  
....................             Start++;  
034F:  INCF   36,F
....................             printf(Putc,"R");  
0350:  MOVLW  52
0351:  MOVWF  42
0352:  CALL   111
....................             MotorStart(Data);                // rozjezd s nastavenim prodlevy  
0353:  MOVF   35,W
0354:  MOVWF  3E
0355:  CALL   24D
....................   
....................             TimerSet(2000);                  // nastav celkovy cas jizdy  
0356:  MOVLW  07
0357:  MOVWF  3F
0358:  MOVLW  D0
0359:  MOVWF  3E
035A:  CALL   230
....................          }  
....................   
....................          // Zastaveni  
....................          if ((Start==2) && TimerIf())  
035B:  MOVF   36,W
035C:  SUBLW  02
035D:  BTFSS  03.2
035E:  GOTO   369
035F:  CALL   237
0360:  MOVF   78,F
0361:  BTFSC  03.2
0362:  GOTO   369
....................          {  
....................             Start++;  
0363:  INCF   36,F
....................             printf(Putc,"S");  
0364:  MOVLW  53
0365:  MOVWF  42
0366:  CALL   111
....................             MotorSet(0);                     // pokud dobehl casovac zastav motor  
0367:  CLRF   3E
0368:  CALL   224
....................          }  
....................   
....................          // watch dog  
....................          restart_wdt();  
0369:  CLRWDT
....................       }  
036A:  GOTO   31F
....................    }  
....................   
....................    // ALG=3 Test nabijeciho algoritmu  
....................    // ===============================  
....................    // P1 nastavuje pozadovane napeti na clancich (meri se Vref vuci napajeni)  
....................    // Nacitani P1 probiha stale dokola, pro rizeni je pouzit stejny  
....................    // algoritmus jako pro standardni jizdu  
....................    if (Debug==3)  
036B:  MOVF   30,W
036C:  SUBLW  03
036D:  BTFSS  03.2
036E:  GOTO   3C2
....................    {  
....................       unsigned int8 PwmOut;   // akcni hodnota pro PWM  
....................       unsigned int8 Req;      // pozadovana hodnota z P1  
....................       unsigned int8 Vref;     // merena hodnota vref  
....................   
....................       // Inicializace stavove promenne  
....................       PwmOut=0;  
036F:  CLRF   37
....................   
....................       // Hlavni smycka  
....................       while (1)  
....................       {  
....................          // watch dog  
....................          restart_wdt();  
0370:  CLRWDT
....................   
....................          // pozadovana hodnota (potenciometr P1)  
....................          Req=ReadAD(0);  
0371:  CLRF   3E
0372:  CALL   195
0373:  MOVF   78,W
0374:  MOVWF  38
....................          Req=50+(ReadAD(0)>>1);                      // 50 az 177  
0375:  CLRF   3E
0376:  CALL   195
0377:  BCF    03.0
0378:  RRF    78,W
0379:  ADDLW  32
037A:  MOVWF  38
....................   
....................          // napeti na napajeni (vref)  
....................          Vref=ReadAD(4);  
037B:  MOVLW  04
037C:  MOVWF  3E
037D:  CALL   195
037E:  MOVF   78,W
037F:  MOVWF  39
....................   
....................          // ricici algoritmus  
....................          if ((Vref<Req) &&(PwmOut<30)) PwmOut++;  
0380:  MOVF   38,W
0381:  SUBWF  39,W
0382:  BTFSC  03.0
0383:  GOTO   388
0384:  MOVF   37,W
0385:  SUBLW  1D
0386:  BTFSC  03.0
0387:  INCF   37,F
....................          if ((Vref>=Req)&&(PwmOut> 0)) PwmOut--;  
0388:  MOVF   38,W
0389:  SUBWF  39,W
038A:  BTFSS  03.0
038B:  GOTO   38F
038C:  MOVF   37,F
038D:  BTFSS  03.2
038E:  DECF   37,F
....................          Vref+=10;  
038F:  MOVLW  0A
0390:  ADDWF  39,F
....................          if ((Vref<(Req))&&(PwmOut<30)) PwmOut++;    // urychleni nabehu  
0391:  MOVF   38,W
0392:  SUBWF  39,W
0393:  BTFSC  03.0
0394:  GOTO   399
0395:  MOVF   37,W
0396:  SUBLW  1D
0397:  BTFSC  03.0
0398:  INCF   37,F
....................   
....................          // nastaveni parametru PWM  
....................          if (PwmOut>24) PwmOut=24;     // saturace  
0399:  MOVF   37,W
039A:  SUBLW  18
039B:  BTFSC  03.0
039C:  GOTO   39F
039D:  MOVLW  18
039E:  MOVWF  37
....................          CCPR1L = PwmOut;              // pouziti vystupu  
039F:  MOVF   37,W
03A0:  MOVWF  15
....................   
....................          // zobrazeni  
....................          printf(Putc,"\nALG:%03u %03u %03u",Req,Vref,PwmOut);  
03A1:  CLRF   3E
03A2:  MOVF   3E,W
03A3:  CALL   07D
03A4:  INCF   3E,F
03A5:  MOVWF  77
03A6:  MOVWF  42
03A7:  CALL   111
03A8:  MOVLW  05
03A9:  SUBWF  3E,W
03AA:  BTFSS  03.2
03AB:  GOTO   3A2
03AC:  MOVF   38,W
03AD:  MOVWF  40
03AE:  CLRF   41
03AF:  CALL   1C0
03B0:  MOVLW  20
03B1:  MOVWF  42
03B2:  CALL   111
03B3:  MOVF   39,W
03B4:  MOVWF  40
03B5:  CLRF   41
03B6:  CALL   1C0
03B7:  MOVLW  20
03B8:  MOVWF  42
03B9:  CALL   111
03BA:  MOVF   37,W
03BB:  MOVWF  40
03BC:  CLRF   41
03BD:  CALL   1C0
....................          delay_ms(10);  
03BE:  MOVLW  0A
03BF:  MOVWF  3E
03C0:  CALL   20D
....................       }  
03C1:  GOTO   370
....................    }  
....................   
....................    // ALG=0 Standardni jizda  
....................    // ======================  
....................    // P1 nastavuje pozadovane napeti na clancich  
....................    // P2 nastavuje prodlevu razeni pri rozjezdu, nacita se jen 1x na zacatku  
....................    // Po resetu cca 14.5 sekundy akumuluje do kondenzatoru a pak provede  
....................    // rozjezd motoru. Po celou dobu probiha rizeni zateze slunecnich clanku.  
....................    // Parametry P1 a P2 jsou chapany stejne jako v algoritmech 2 a 3.  
....................    if (Debug==0)  
03C2:  MOVF   30,F
03C3:  BTFSS  03.2
03C4:  GOTO   449
....................    {  
....................       unsigned int8 PwmOut;   // akcni hodnota pro PWM  
....................       unsigned int8 Req;      // pozadovana hodnota z P1  
....................       unsigned int8 Vref;     // merena hodnota vref  
....................       int8 Delay;             // pozadovana honota prodlevy razeni z P2  
....................       int1 Run;  
....................   
....................       // Nacti parametr rozjezdu  
....................       Delay=ReadAD(1);                    // potenciometr P2 = rozjezd  
03C5:  MOVLW  01
03C6:  MOVWF  3E
03C7:  CALL   195
03C8:  MOVF   78,W
03C9:  MOVWF  3D
....................       printf(Putc," RUN:%3ums ",Delay);  // zobraz  
03CA:  CLRF   3E
03CB:  MOVF   3E,W
03CC:  CALL   095
03CD:  INCF   3E,F
03CE:  MOVWF  77
03CF:  MOVWF  42
03D0:  CALL   111
03D1:  MOVLW  05
03D2:  SUBWF  3E,W
03D3:  BTFSS  03.2
03D4:  GOTO   3CB
03D5:  MOVF   3D,W
03D6:  MOVWF  40
03D7:  MOVLW  10
03D8:  MOVWF  41
03D9:  CALL   1C0
03DA:  MOVLW  6D
03DB:  MOVWF  42
03DC:  CALL   111
03DD:  MOVLW  73
03DE:  MOVWF  42
03DF:  CALL   111
03E0:  MOVLW  20
03E1:  MOVWF  42
03E2:  CALL   111
....................       delay_ms(10);                       // prodleva pro terminal  
03E3:  MOVLW  0A
03E4:  MOVWF  3E
03E5:  CALL   20D
....................   
....................       // Inicializace stavove promenne  
....................       PwmOut=0;  
03E6:  CLRF   3A
....................       TimerSet(14000);        // casovani startu  
03E7:  MOVLW  36
03E8:  MOVWF  3F
03E9:  MOVLW  B0
03EA:  MOVWF  3E
03EB:  CALL   230
....................       Run=1;  
03EC:  BSF    32.1
....................   
....................       // Hlavni smycka  
....................       while (1)  
....................       {  
....................          // watch dog  
....................          restart_wdt();  
03ED:  CLRWDT
....................   
....................          // pozadovana hodnota (potenciometr P1)  
....................          Req=ReadAD(0);  
03EE:  CLRF   3E
03EF:  CALL   195
03F0:  MOVF   78,W
03F1:  MOVWF  3B
....................          Req=50+(ReadAD(0)>>1);                      // 50 az 177  
03F2:  CLRF   3E
03F3:  CALL   195
03F4:  BCF    03.0
03F5:  RRF    78,W
03F6:  ADDLW  32
03F7:  MOVWF  3B
....................   
....................          // napeti na napajeni (vref)  
....................          Vref=ReadAD(4);  
03F8:  MOVLW  04
03F9:  MOVWF  3E
03FA:  CALL   195
03FB:  MOVF   78,W
03FC:  MOVWF  3C
....................   
....................          // ricici algoritmus  
....................          if ((Vref<Req) &&(PwmOut<30)) PwmOut++;  
03FD:  MOVF   3B,W
03FE:  SUBWF  3C,W
03FF:  BTFSC  03.0
0400:  GOTO   405
0401:  MOVF   3A,W
0402:  SUBLW  1D
0403:  BTFSC  03.0
0404:  INCF   3A,F
....................          if ((Vref>=Req)&&(PwmOut> 0)) PwmOut--;  
0405:  MOVF   3B,W
0406:  SUBWF  3C,W
0407:  BTFSS  03.0
0408:  GOTO   40C
0409:  MOVF   3A,F
040A:  BTFSS  03.2
040B:  DECF   3A,F
....................          Vref+=10;  
040C:  MOVLW  0A
040D:  ADDWF  3C,F
....................          if ((Vref<(Req))&&(PwmOut<30)) PwmOut++;    // urychleni nabehu  
040E:  MOVF   3B,W
040F:  SUBWF  3C,W
0410:  BTFSC  03.0
0411:  GOTO   416
0412:  MOVF   3A,W
0413:  SUBLW  1D
0414:  BTFSC  03.0
0415:  INCF   3A,F
....................   
....................          // nastaveni parametru PWM  
....................          if (PwmOut>24) PwmOut=24;     // saturace  
0416:  MOVF   3A,W
0417:  SUBLW  18
0418:  BTFSC  03.0
0419:  GOTO   41C
041A:  MOVLW  18
041B:  MOVWF  3A
....................          CCPR1L = PwmOut;              // pouziti vystupu  
041C:  MOVF   3A,W
041D:  MOVWF  15
....................   
....................          // zobrazeni  
....................          printf(Putc,"\nALG:%03u %03u %03u",Req,Vref,PwmOut);  
041E:  CLRF   3E
041F:  MOVF   3E,W
0420:  CALL   07D
0421:  INCF   3E,F
0422:  MOVWF  77
0423:  MOVWF  42
0424:  CALL   111
0425:  MOVLW  05
0426:  SUBWF  3E,W
0427:  BTFSS  03.2
0428:  GOTO   41F
0429:  MOVF   3B,W
042A:  MOVWF  40
042B:  CLRF   41
042C:  CALL   1C0
042D:  MOVLW  20
042E:  MOVWF  42
042F:  CALL   111
0430:  MOVF   3C,W
0431:  MOVWF  40
0432:  CLRF   41
0433:  CALL   1C0
0434:  MOVLW  20
0435:  MOVWF  42
0436:  CALL   111
0437:  MOVF   3A,W
0438:  MOVWF  40
0439:  CLRF   41
043A:  CALL   1C0
....................          delay_ms(10);  
043B:  MOVLW  0A
043C:  MOVWF  3E
043D:  CALL   20D
....................   
....................          // rozjezd  
....................          if (TimerIf()&&Run)  
043E:  CALL   237
043F:  MOVF   78,F
0440:  BTFSC  03.2
0441:  GOTO   448
0442:  BTFSS  32.1
0443:  GOTO   448
....................          {  
....................             Run=0;  
0444:  BCF    32.1
....................             MotorStart(Delay);         // prodleva razeni z P2  
0445:  MOVF   3D,W
0446:  MOVWF  3E
0447:  CALL   24D
....................          }  
....................       }  
0448:  GOTO   3ED
....................    }  
.................... }  
....................  
0449:  SLEEP

Configuration Fuses:
   Word  1: 2F3C   WDT NOPUT MCLR NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG CCPB3 NOPROTECT INTRC_IO
   Word  2: 3FFF   FCMEN IESO
